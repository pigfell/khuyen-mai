<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Caro 15x19 Mobile - Trainer Log</title>
    <style>
        :root {
            --cell-size: 6.5vw;
            --bg-color: #f4f4f4;
            --board-bg: #eecfa1;
            --line-color: #5d4037;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: var(--bg-color);
            margin: 0;
            padding: 5px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        h2 { margin: 0 0 5px 0; font-size: 1.1rem; color: #333; }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            justify-content: center;
            margin-bottom: 5px;
            width: 96%;
            background: white;
            padding: 5px;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        select, button {
            padding: 6px;
            font-size: 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: #fff;
            flex-grow: 1;
            text-align: center;
        }

        .action-btn { background: #f8f9fa; font-weight: 500; }
        .action-btn:active { background: #e2e6ea; }
        
        button.reset-btn { background: #dc3545; color: white; border: none; flex-grow: 0; }
        button.copy-btn { background: #28a745; color: white; border: none; }

        #status {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 5px;
            padding: 2px 10px;
            border-radius: 12px;
            background: #fff;
            color: #333;
            text-align: center;
        }

        .board-wrapper {
            position: relative;
            padding-top: 20px;
            padding-left: 20px;
            background: var(--board-bg);
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .coord-top { position: absolute; top: 0; left: 20px; right: 0; height: 20px; display: flex; }
        .coord-top div { flex: 1; text-align: center; line-height: 20px; font-size: 9px; font-weight: bold; color: #5d4037; }

        .coord-left { position: absolute; top: 20px; left: 0; bottom: 0; width: 20px; display: flex; flex-direction: column; }
        .coord-left div { flex: 1; text-align: center; display: flex; align-items: center; justify-content: center; font-size: 9px; font-weight: bold; color: #5d4037; }

        .board {
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(19, 1fr); 
            width: 94vw; 
            height: calc(94vw * (19/15)); 
            border-top: 1px solid var(--line-color);
            border-left: 1px solid var(--line-color);
            background-color: var(--board-bg);
        }

        .cell {
            position: relative;
            border-right: 1px solid var(--line-color);
            border-bottom: 1px solid var(--line-color);
            display: flex; justify-content: center; align-items: center;
        }

        .cell::after {
            content: ''; width: 75%; height: 75%; border-radius: 50%; display: none;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            font-family: sans-serif; font-weight: bold; font-size: 0.6rem;
            justify-content: center; align-items: center; color: white;
        }

        .cell.x::after { display: flex; background: #2196F3; content: "X"; }
        .cell.o::after { display: flex; background: #f44336; content: "O"; }
        .cell.last-move { background-color: rgba(255, 255, 255, 0.45); }
        .cell.win { background-color: #ffeb3b !important; }

        /* Log Section */
        .log-container {
            width: 96%;
            margin-top: 10px;
            background: white;
            padding: 5px;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        textarea#moveLog {
            width: 100%;
            height: 60px;
            font-family: monospace;
            font-size: 11px;
            border: 1px solid #ddd;
            resize: none;
            box-sizing: border-box;
            padding: 5px;
        }

        @media (min-width: 600px) {
            .board { width: 450px; height: 570px; }
            .board-wrapper { padding-top: 25px; padding-left: 25px; }
            .coord-top { height: 25px; left: 25px; } .coord-top div { font-size: 11px; line-height: 25px; }
            .coord-left { width: 25px; top: 25px; } .coord-left div { font-size: 11px; }
            .cell.x::after, .cell.o::after { font-size: 0.9rem; }
        }
    </style>
</head>
<body>

    <h2>Caro Pro 15x19</h2>

    <div class="controls">
        <select id="mode" onchange="resetGame()">
            <option value="human">Ng∆∞·ªùi vs Ng∆∞·ªùi</option>
            <option value="computer">Ng∆∞·ªùi vs M√°y</option>
        </select>
        <select id="rule" onchange="resetGame()">
            <option value="blocked">Ch·∫∑n 2 ƒë·∫ßu</option>
            <option value="free">T·ª± do</option>
        </select>
        <select id="starter" onchange="resetGame()">
            <option value="x">Ch·ªçn X (X ƒë√°nh tr∆∞·ªõc)</option>
            <option value="o">Ch·ªçn O (O ƒë√°nh sau)</option>
        </select>
    </div>
    
    <div class="controls">
        <button class="action-btn" onclick="undoMove()">‚Ü© Ho√†n t√°c</button>
        <button class="action-btn" onclick="redoMove()">‚Ü™ Tr·ªü l·∫°i</button>
        <button class="reset-btn" onclick="resetGame()">Ch∆°i l·∫°i</button>
    </div>

    <div id="status">S·∫µn s√†ng!</div>

    <div class="board-wrapper">
        <div class="coord-top" id="coordTop"></div>
        <div class="coord-left" id="coordLeft"></div>
        <div class="board" id="board"></div>
    </div>

    <div class="log-container">
        <textarea id="moveLog" readonly placeholder="Bi√™n b·∫£n n∆∞·ªõc ƒëi (VD: H10, G11...)"></textarea>
        <button class="copy-btn" onclick="copyLog()">üìã Copy Log (ƒê·ªÉ n·∫°p v√†o Bot kh√°c)</button>
    </div>

<script>
    const COLS = 15;
    const ROWS = 19;
    const COL_LABELS = "ABCDEFGHIJKLMNO".split('');
    let board = [];
    let currentPlayer = 'x';
    let isGameActive = false;
    let history = []; 
    let redoStack = []; 

    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const modeEl = document.getElementById('mode');
    const ruleEl = document.getElementById('rule');
    const starterEl = document.getElementById('starter');
    const logEl = document.getElementById('moveLog');

    function initUI() {
        const top = document.getElementById('coordTop');
        for(let i=0; i<COLS; i++) {
            let d = document.createElement('div');
            d.innerText = COL_LABELS[i];
            top.appendChild(d);
        }
        const left = document.getElementById('coordLeft');
        for(let i=0; i<ROWS; i++) {
            let d = document.createElement('div');
            d.innerText = i + 1;
            left.appendChild(d);
        }
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                let cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.r = r;
                cell.dataset.c = c;
                cell.addEventListener('click', () => onCellClick(r, c));
                boardEl.appendChild(cell);
            }
        }
    }

    function resetGame() {
        board = Array(ROWS).fill(null).map(() => Array(COLS).fill(null));
        isGameActive = true;
        history = [];
        redoStack = [];
        updateLog();
        
        document.querySelectorAll('.cell').forEach(c => c.className = 'cell');
        
        // 1. Lu√¥n X ƒëi tr∆∞·ªõc ·ªü H10
        currentPlayer = 'x';
        makeMove(9, 7, 'x', true); // H10

        const userSide = starterEl.value;
        const mode = modeEl.value;

        if (mode === 'computer') {
            if (userSide === 'x') {
                // User ch·ªçn X: Bot (O) ƒë√°nh tr·∫£
                setTimeout(botMove, 500);
            }
            // User ch·ªçn O: User ƒë√°nh O sau khi X ƒë√£ hi·ªán H10
        }
        updateStatus();
    }

    function updateStatus() {
        if (!isGameActive) return;
        statusEl.innerText = `L∆∞·ª£t ƒëi: ${currentPlayer.toUpperCase()}`;
        statusEl.style.color = currentPlayer === 'x' ? '#007bff' : '#dc3545';
    }

    // --- LOGIC GHI LOG ---
    function getMoveNotation(r, c) {
        return COL_LABELS[c] + (r + 1);
    }

    function updateLog() {
        let text = "";
        history.forEach((move, index) => {
            let notation = getMoveNotation(move.r, move.c);
            text += `${index + 1}.${notation} `;
        });
        logEl.value = text;
        logEl.scrollTop = logEl.scrollHeight; // Auto scroll xu·ªëng d∆∞·ªõi
    }

    function copyLog() {
        logEl.select();
        logEl.setSelectionRange(0, 99999);
        navigator.clipboard.writeText(logEl.value).then(() => {
            alert("ƒê√£ copy bi√™n b·∫£n v√°n ƒë·∫•u!");
        });
    }

    // --- X·ª¨ L√ù GAME ---

    function onCellClick(r, c) {
        if (!isGameActive || board[r][c] !== null) return;
        
        const userSide = starterEl.value;
        const mode = modeEl.value;
        if(mode === 'computer') {
            if(userSide === 'x' && currentPlayer === 'o') return;
            if(userSide === 'o' && currentPlayer === 'x') return;
        }

        makeMove(r, c, currentPlayer);

        if (isGameActive && modeEl.value === 'computer') {
            setTimeout(botMove, 200);
        }
    }

    function makeMove(r, c, player, isSetup = false) {
        board[r][c] = player;
        history.push({r, c, player});
        redoStack = [];
        
        updateCellUI(r, c, player);
        highlightLastMove(r, c);
        updateLog(); // C·∫≠p nh·∫≠t log ngay

        if (checkWin(r, c, player)) {
            statusEl.innerText = `${player.toUpperCase()} TH·∫ÆNG!`;
            statusEl.style.color = "#28a745";
            isGameActive = false;
            setTimeout(() => { resetGame(); }, 1500);
            return;
        }

        if (history.length >= ROWS * COLS) {
            statusEl.innerText = "H√íA C·ªú!";
            isGameActive = false;
            setTimeout(resetGame, 1500);
            return;
        }

        currentPlayer = currentPlayer === 'x' ? 'o' : 'x';
        if(!isSetup) updateStatus();
    }

    function updateCellUI(r, c, type) {
        let cell = document.querySelector(`.cell[data-r='${r}'][data-c='${c}']`);
        if (type === null) cell.className = 'cell';
        else cell.classList.add(type);
    }

    function highlightLastMove(r, c) {
        document.querySelectorAll('.last-move').forEach(el => el.classList.remove('last-move'));
        if (r !== null && c !== null) {
            let cell = document.querySelector(`.cell[data-r='${r}'][data-c='${c}']`);
            if(cell) cell.classList.add('last-move');
        }
    }

    function undoMove() {
        if (history.length <= 1) return; // Gi·ªØ H10

        if (modeEl.value === 'computer') {
            // Undo Bot
            let last = history.pop();
            board[last.r][last.c] = null;
            updateCellUI(last.r, last.c, null);
            redoStack.push(last);

            // Undo User
            if(history.length > 0) {
                let prev = history.pop();
                board[prev.r][prev.c] = null;
                updateCellUI(prev.r, prev.c, null);
                redoStack.push(prev);
                currentPlayer = prev.player; 
            }
        } else {
            let last = history.pop();
            redoStack.push(last);
            board[last.r][last.c] = null;
            updateCellUI(last.r, last.c, null);
            currentPlayer = last.player;
        }

        isGameActive = true;
        updateStatus();
        updateLog(); // C·∫≠p nh·∫≠t log
        
        if (history.length > 0) {
            let prev = history[history.length - 1];
            highlightLastMove(prev.r, prev.c);
        } else {
            highlightLastMove(null, null);
        }
    }

    function redoMove() {
        if (redoStack.length === 0) return;

        if (modeEl.value === 'computer') {
            let move1 = redoStack.pop();
            board[move1.r][move1.c] = move1.player;
            history.push(move1);
            updateCellUI(move1.r, move1.c, move1.player);
            
            if(redoStack.length > 0) {
                let move2 = redoStack.pop();
                board[move2.r][move2.c] = move2.player;
                history.push(move2);
                updateCellUI(move2.r, move2.c, move2.player);
                highlightLastMove(move2.r, move2.c);
            } else {
                highlightLastMove(move1.r, move1.c);
                setTimeout(botMove, 500);
            }
        } else {
            let next = redoStack.pop();
            board[next.r][next.c] = next.player;
            history.push(next);
            updateCellUI(next.r, next.c, next.player);
            highlightLastMove(next.r, next.c);
            currentPlayer = next.player === 'x' ? 'o' : 'x';
        }
        updateStatus();
        updateLog(); // C·∫≠p nh·∫≠t log
    }

    function checkWin(r, c, player) {
        const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
        const isBlockedRule = ruleEl.value === 'blocked';
        for (let [dr, dc] of directions) {
            let count = 1, blockedEnds = 0, cells = [{r,c}];
            let i = 1;
            while (true) {
                let nr = r+dr*i, nc = c+dc*i;
                if (nr<0||nr>=ROWS||nc<0||nc>=COLS) { blockedEnds++; break; }
                if (board[nr][nc]===player) { count++; cells.push({r:nr,c:nc}); i++; }
                else { if(board[nr][nc]!==null) blockedEnds++; break; }
            }
            let j = 1;
            while (true) {
                let nr = r-dr*j, nc = c-dc*j;
                if (nr<0||nr>=ROWS||nc<0||nc>=COLS) { blockedEnds++; break; }
                if (board[nr][nc]===player) { count++; cells.push({r:nr,c:nc}); j++; }
                else { if(board[nr][nc]!==null) blockedEnds++; break; }
            }
            if (count >= 5) {
                if (isBlockedRule && blockedEnds === 2) continue;
                cells.forEach(p => document.querySelector(`.cell[data-r='${p.r}'][data-c='${p.c}']`).classList.add('win'));
                return true;
            }
        }
        return false;
    }

    function botMove() {
        if (!isGameActive) return;
        let candidates = getCandidates();
        if (candidates.length === 0) return;

        let bestScore = -Infinity, bestMoves = [];
        for (let {r, c} of candidates) {
            let score = evaluate(r, c, currentPlayer);
            if (score > bestScore) { bestScore = score; bestMoves = [{r, c}]; }
            else if (score === bestScore) bestMoves.push({r, c});
        }
        if (bestMoves.length > 0) {
            let move = bestMoves[Math.floor(Math.random() * bestMoves.length)];
            makeMove(move.r, move.c, currentPlayer);
        }
    }

    function getCandidates() {
        let candidates = [], visited = new Set(), hasPiece = false;
        for(let r=0; r<ROWS; r++){
            for(let c=0; c<COLS; c++){
                if(board[r][c] !== null) {
                    hasPiece = true;
                    for(let dr=-2; dr<=2; dr++){
                        for(let dc=-2; dc<=2; dc++){
                            let nr = r+dr, nc = c+dc;
                            if(nr>=0 && nr<ROWS && nc>=0 && nc<COLS && board[nr][nc]===null) {
                                let key = nr+","+nc;
                                if(!visited.has(key)){ visited.add(key); candidates.push({r:nr, c:nc}); }
                            }
                        }
                    }
                }
            }
        }
        if(!hasPiece) return [{r:9, c:7}];
        return candidates;
    }

    function evaluate(r, c, botColor) {
        let humanColor = botColor === 'x' ? 'o' : 'x';
        let attack = getScore(r, c, botColor, 1.2);
        let defense = getScore(r, c, humanColor, 1.0);
        return Math.max(attack, defense);
    }

    function getScore(r, c, player, multiplier) {
        const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
        let score = 0;
        let isBlockedMode = ruleEl.value === 'blocked';
        for (let [dr, dc] of directions) {
            let count = 1, block = 0;
            for(let dir of [1, -1]) {
                let i = 1;
                while(true) {
                    let nr = r + dr*dir*i, nc = c + dc*dir*i;
                    if (nr<0||nr>=ROWS||nc<0||nc>=COLS) { block++; break; }
                    if (board[nr][nc]===player) { count++; i++; }
                    else if (board[nr][nc]!==null) { block++; break; }
                    else break; 
                }
            }
            if (count >= 5) {
                if (isBlockedMode && block === 2) score += 0;
                else score += 1000000;
            } else if (count === 4) {
                if (block === 0) score += 50000;
                else if (block === 1) score += 4000;
            } else if (count === 3) {
                if (block === 0) score += 2000;
                else if (block === 1) score += 100;
            } else if (count === 2) {
                 if (block === 0) score += 50;
            }
        }
        return score * multiplier;
    }

    initUI();
    resetGame();
</script>
</body>
</html>
